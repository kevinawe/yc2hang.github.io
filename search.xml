<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer-对称的二叉树</title>
      <link href="/2020/09/21/%E5%89%91%E6%8C%87offer-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/09/21/%E5%89%91%E6%8C%87offer-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><a id="more"></a><blockquote><p>原题描述访问：<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/</a></p></blockquote><p><strong>思路</strong><br>对于树中 任意两个对称节点L和R 一定有：<br>    - L.val=R.val ：即此两对称节点值相等。<br>    - L.left.val=R.right.val<br>    - L.right.val=R.left.val</p><p><strong>代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> helper = <span class="function"><span class="keyword">function</span>(<span class="params">left_root, right_root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left_root &amp;&amp; !right_root) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span>(!left_root || !right_root) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span>(left_root.val !== right_root.val) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> helper(left_root.left, right_root.right) &amp;&amp; helper(left_root.right, right_root.left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !root ? <span class="literal">true</span> : helper(root.left, root.right)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-二叉树的镜像</title>
      <link href="/2020/09/21/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
      <url>/2020/09/21/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><a id="more"></a><blockquote><p>原题描述访问：<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/</a></p></blockquote><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 / 右子节点，即可生成二叉树的镜像。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mirrorTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || root.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> tmp = root.left</span><br><span class="line">    root.left = mirrorTree(root.right)</span><br><span class="line">    root.right = mirrorTree(tmp)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="辅助栈"><a href="#辅助栈" class="headerlink" title="辅助栈"></a>辅助栈</h3><p>利用栈（或队列）遍历树的所有节点 node，并交换每个 node 的左 / 右子节点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mirrorTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || root.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> stack = [root]</span><br><span class="line">    <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">        <span class="keyword">let</span> node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">            stack.push(node.left)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">            stack.push(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> tmp = node.left</span><br><span class="line">        node.left = node.right</span><br><span class="line">        node.right = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> bfs </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer-重建二叉树</title>
      <link href="/2020/09/21/%E5%89%91%E6%8C%87offer-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/09/21/%E5%89%91%E6%8C%87offer-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><a id="more"></a><blockquote><p>原题描述访问：<a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/</a></p></blockquote><p><strong>代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!preorder.length || !inorder.length) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> root = preorder[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> TreeNode(root)</span><br><span class="line">    <span class="keyword">let</span> idx = inorder.indexOf(root)</span><br><span class="line">    node.left = buildTree(preorder.slice(<span class="number">1</span>, idx+<span class="number">1</span>), inorder.slice(<span class="number">0</span>, idx))</span><br><span class="line">    node.right = buildTree(preorder.slice(idx+<span class="number">1</span>), inorder.slice(idx+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-单词搜索</title>
      <link href="/2020/09/16/leetcode-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/"/>
      <url>/2020/09/16/leetcode-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><a id="more"></a><blockquote><p>原题描述访问：<a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-search/</a><br>题解转自：<a href="https://leetcode-cn.com/problems/word-search/solution/shou-hua-tu-jie-79-dan-ci-sou-suo-dfs-si-lu-de-cha/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-search/solution/shou-hua-tu-jie-79-dan-ci-sou-suo-dfs-si-lu-de-cha/</a></p></blockquote><p><strong>题意</strong><br>给你一个由字母组成的二维矩阵，和一个单词，能否在矩阵中“勾勒”出一条路径，路径上的字母组成了这个单词。</p><p><strong>思路</strong><br>比如单词 “SEE”，首先起点要对，遍历一遍矩阵，看看哪里有起点 S。<br>起点可能不止一个，基于其中一个 S，能否找出剩下的 “EE” 路径。其实已经有了深搜的思路了。<br>下一个字符 E，有四个可选点：当前 S 点的上、下、左、右。<br>逐个尝试每一种选择，去探索。基于其中一种选择，又要为下一个字符选点，又有四种选择，继续尝试，探索。回溯的思路就有了。<br>每到一个点，做的事情是一样的，是递归DFS。路径类问题经常是 DFS——往下选点，构建路径。<br>当发现某个选择不对，不要继续选下去了，结束当前递归，考察别的选择。</p><p><strong>递归总是关注当前</strong><br>我们在写递归函数时，关注当前，当前考察的点，哪些是当前递归该处理的，哪些是丢给递归子调用去做的。<br>当前递归本身做的事：判断当前选择的点，本身有没有问题，是不是错的。<br>至于剩下的字符，能否找到路径，这件事，交给递归子调用去深搜。<br>如果当前点是错的，也不用往下递归了，直接返回false。否则继续递归搜四个方向，为剩下的字符选点。</p><p><strong>哪些情况说明这是一个错的选择呢？（递归的结束条件）</strong></p><ol><li>当前的点，超出矩阵，不存在。</li><li>当前的点，之前来过了，不符合「同一个单元格内的字母不允许被重复使用」</li><li>当前的点，不是目标点，比如你想找 E，却来了 D。</li></ol><p><strong>当前的点，不是目标点，比如你想找 E，却来了 D。</strong><br>用一个二维矩阵 used，记录已经访问过的点，下次再选择访问这个点，就直接返回 false。</p><p><strong>代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> exist = <span class="function">(<span class="params">board, word</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> m = board.length;</span><br><span class="line">  <span class="keyword">const</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">  <span class="keyword">const</span> used = <span class="keyword">new</span> <span class="built_in">Array</span>(m);    <span class="comment">// 二维矩阵used</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    used[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断当前点是否是目标路径上的点</span></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">row, col, i</span>) =&gt;</span> &#123; <span class="comment">// row col是当前点的坐标，i是当前考察的字符索引</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; word.length - <span class="number">1</span>) &#123;       <span class="comment">// 递归的出口</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= m || col &lt; <span class="number">0</span> || col &gt;= n) &#123; <span class="comment">// 当前点要存在</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (used[row][col] || board[row][col] != word[i]) &#123; <span class="comment">// 当前的点已经走过，或当前点就不是目标点</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排除掉这些false情况，当前点是没问题的，可以继续递归考察</span></span><br><span class="line">    used[row][col] = <span class="literal">true</span>;  <span class="comment">// used记录一下当前点被访问了</span></span><br><span class="line">    <span class="keyword">const</span> canFindRest =</span><br><span class="line">      dfs(row + <span class="number">1</span>, col, i + <span class="number">1</span>) ||</span><br><span class="line">      dfs(row - <span class="number">1</span>, col, i + <span class="number">1</span>) ||</span><br><span class="line">      dfs(row, col + <span class="number">1</span>, i + <span class="number">1</span>) ||</span><br><span class="line">      dfs(row, col - <span class="number">1</span>, i + <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canFindRest) &#123; <span class="comment">// 基于当前点，可以为剩下的字符找到路径</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    used[row][col] = <span class="literal">false</span>; <span class="comment">// 找不出，返回false，继续考察别的分支，并撤销当前点的访问状态。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>] &amp;&amp; dfs(i, j, <span class="number">0</span>)) &#123; <span class="comment">// 找到dfs的起点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到起点，且dfs的结果也true，则找到了目标路径</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 怎么样都没有返回true，则返回false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> leetcode </tag>
            
            <tag> dfs </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-组合总和3</title>
      <link href="/2020/09/12/leetcode-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C3/"/>
      <url>/2020/09/12/leetcode-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C3/</url>
      
        <content type="html"><![CDATA[<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p><a id="more"></a><blockquote><p>原题描述访问：<a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-iii/</a><br>题解转自：<a href="https://leetcode-cn.com/problems/combination-sum-iii/solution/shou-hua-tu-jie-216-zu-he-zong-he-iii-by-xiao_ben_/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-iii/solution/shou-hua-tu-jie-216-zu-he-zong-he-iii-by-xiao_ben_/</a></p></blockquote><p><strong>题意</strong><br>此题与组合总和1，2相似，解法可参考前面<br><strong>代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combinationSum3 = <span class="function">(<span class="params">k, n</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = []; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">start, temp, sum</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (temp.length == k) &#123;     <span class="comment">// You've selected k numbers. End recursion</span></span><br><span class="line">      <span class="keyword">if</span> (sum == n) &#123;           <span class="comment">// The sum of numbers in a combination equals n</span></span><br><span class="line">        res.push(temp.slice()); <span class="comment">// Add its copy to the solution set</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= <span class="number">9</span>; i++) &#123; <span class="comment">// Enumerate the options</span></span><br><span class="line">      temp.push(i);                    <span class="comment">// Make a choice</span></span><br><span class="line">      dfs(i + <span class="number">1</span>, temp, sum + i);       <span class="comment">// Explore</span></span><br><span class="line">      temp.pop();                      <span class="comment">// Undo the choice</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dfs(<span class="number">1</span>, [], <span class="number">0</span>);  <span class="comment">// press the search button</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> leetcode </tag>
            
            <tag> dfs </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="/2020/09/11/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2020/09/11/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>回溯跟递归，深度搜索遍历结合使用，是非常普遍的算法思路。下面介绍回溯思路</p><a id="more"></a><blockquote><p>转自题解：<a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/man-tan-wo-li-jie-de-hui-su-chang-wen-shou-hua-tu-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii/solution/man-tan-wo-li-jie-de-hui-su-chang-wen-shou-hua-tu-/</a></p></blockquote><h3 id="回溯的要素"><a href="#回溯的要素" class="headerlink" title="回溯的要素"></a>回溯的要素</h3><p>我们关心，当前局面下，我们有什么选择，作了一个选择之后，下一个选择会有什么限制。</p><p>解空间树的节点是动态的，当前的选择决定了下一个选择是怎么展开的。</p><p>所以，不仅要关注 options，还要关注 restraints 约束。</p><p>前者用于展开出一棵解的空间树，后者用于为这棵树剪枝，剪去不能产生正确解的节点，避免无效搜索。</p><p>第三个要素：目标（结束条件），明确了目标，就知道何时去将解加入解集。</p><p>并且让你知道：探索到某一步时，发现当前的部分解不能通向正确的完整解，搜下去没有意义。</p><p>此时回退一步，撤销当前的选择，回到上一个选择的状态，做别的选择。</p><p>此路不通，退回去，尝试别的路，是一个「choose, explore, unchoose」的过程。</p><h3 id="套路做法"><a href="#套路做法" class="headerlink" title="套路做法"></a>套路做法</h3><ol><li>用 for 循环去枚举出所有的选择</li><li>做出一个选择</li><li>基于这个选择，继续往下选择（递归）</li><li>上面的递归结束了，撤销这个选择，进入 for 循环的下一次迭代</li></ol><h3 id="回溯与嵌套循环"><a href="#回溯与嵌套循环" class="headerlink" title="回溯与嵌套循环"></a>回溯与嵌套循环</h3><p>回溯是一种算法，递归不是算法，是一种计算机解决问题的方式。</p><p>回溯是借助递归实现的。如果回溯不借助递归，它只能借助循环。</p><p>用 for 循环枚举出当前的选项，选了一个，选下一个，又要嵌套一层循环，枚举出可选的选项。</p><p>如果要选很多个，就导致多重的循环嵌套，很费力也很丑。</p><p>于是借助递归解决，因为递归和子递归就是层级嵌套的关系。</p><p>而且，树在结构上，具有高度的重复性，每一个节点，都是当前子树的根节点，调用递归函数负责当前子树的搜索。</p><h3 id="虚拟的解空间树"><a href="#虚拟的解空间树" class="headerlink" title="虚拟的解空间树"></a>虚拟的解空间树</h3><p>回溯算法并没有显式地创建数据结构，也不是基于已有的数据结构做搜索。</p><p>它是隐式地，通过递归，构建出一棵解的空间树。这个空间树中包含了所有的解。</p><p>然后通过 dfs 的搜索方式，把解给全部找出来。</p><p>如果说它难，应该难在确定出容易搜索（经过充分的剪枝）的解空间结构，剩下的 dfs 和回溯就比较简单了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> dfs </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-组合总和2</title>
      <link href="/2020/09/11/leetcode-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C2/"/>
      <url>/2020/09/11/leetcode-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C2/</url>
      
        <content type="html"><![CDATA[<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用一次。</p><a id="more"></a><blockquote><p>原题描述访问：<a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii/</a><br>题解转自：<a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/man-tan-wo-li-jie-de-hui-su-chang-wen-shou-hua-tu-/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum-ii/solution/man-tan-wo-li-jie-de-hui-su-chang-wen-shou-hua-tu-/</a></p></blockquote><p><strong>思路</strong><br>以 [2,5,2,1,2], target = 5 为例。</p><p>每个节点都作出选择，选一个数，看看下一个选择受到哪些限制：选过的不能再选，且不能产生相同的组合。去做剪枝（如下图所标）。</p><p>当和为 target，找到一个正确的解，加入解集。且当和 &gt;= target，已经爆掉了，不用继续选了，结束当前递归，继续搜别的分支，找齐所有的解。</p><p>因此，回到上一个节点，撤销当前选择的数字，去进入下一个分支。<br><strong>与组合总和区别</strong></p><ul><li>组合总和：元素可以重复使用，组合不能重复。</li><li>本题：元素不可以重复使用，组合不能重复。</li></ul><p>本题只需改动三点：</p><ol><li>给定的数组可能有重复的元素，先排序，使得重复的数字相邻，方便去重。</li><li>for 循环枚举出选项时，加入下面判断，忽略掉同一层重复的选项，避免产生重复的组合。比如[1,2,2,2,5]中，选了第一个 2，变成 [1,2]，第一个 2 的下一选项也是 2，跳过它，因为选它，就还是 [1,2]。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (candidates[i - <span class="number">1</span>] == candidates[i] &amp;&amp; i - <span class="number">1</span> &gt;= start) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>当前选择的数字不能和下一个选择的数字重复，递归传入i+1，避免与当前选的i重复，这样每次选，就不会选过往选过的同一个数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(i + <span class="number">1</span>, temp, sum + candidates[i]);</span><br></pre></td></tr></table></figure></li></ol><p><strong>代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combinationSum2 = <span class="function">(<span class="params">candidates, target</span>) =&gt;</span> &#123;</span><br><span class="line">  candidates.sort();    <span class="comment">// 排序</span></span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">start, temp, sum</span>) =&gt;</span> &#123; <span class="comment">// start是索引 当前选择范围的第一个</span></span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= target) &#123;        <span class="comment">// 爆掉了，不用继续选了</span></span><br><span class="line">      <span class="keyword">if</span> (sum == target) &#123;      <span class="comment">// 满足条件，加入解集</span></span><br><span class="line">        res.push(temp.slice()); <span class="comment">// temp是地址引用，后续还要用，所以拷贝一份</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;                   <span class="comment">// 结束当前递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; candidates.length; i++) &#123;             <span class="comment">// 枚举出选择</span></span><br><span class="line">      <span class="keyword">if</span> (candidates[i - <span class="number">1</span>] == candidates[i] &amp;&amp; i - <span class="number">1</span> &gt;= start) &#123; <span class="comment">// 当前选项和隔壁选项一样，跳过</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      temp.push(candidates[i]);              <span class="comment">// 作出选择</span></span><br><span class="line">      dfs(i + <span class="number">1</span>, temp, sum + candidates[i]); <span class="comment">// 递归，向下选择，并更新sum</span></span><br><span class="line">      temp.pop();                            <span class="comment">// 撤销选择，</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dfs(<span class="number">0</span>, [], <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> leetcode </tag>
            
            <tag> dfs </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>display,visibility和opacity</title>
      <link href="/2020/09/09/display-visibility%E5%92%8Copacity/"/>
      <url>/2020/09/09/display-visibility%E5%92%8Copacity/</url>
      
        <content type="html"><![CDATA[<p>以下为三者设置样式的区别</p><a id="more"></a><p><strong>display: none</strong></p><ol><li>DOM结构：浏览器不会渲染display属性为none的元素，不占用空间</li><li>事件监听：无法进行DOM事件监听</li><li>性能：动态改变此属性会引起重排，性能较差</li><li>继承：不会被子元素继承，毕竟子类也不会被渲染</li><li>transition：transition不支持display</li></ol><p><strong>visibility: hidden</strong></p><ol><li>DOM结构：元素被隐藏，但是会被渲染，不会消失，占用空间</li><li>事件监听：无法进行DOM事件监听</li><li>性能：动态改变此属性会引起重绘，性能较高</li><li>继承：会被子元素继承，自元素可以通过设置visibility: visible来取消隐藏</li><li>transition：visibility会立即显示，隐藏时会延时</li></ol><p><strong>opacity: 0</strong></p><ol><li>DOM结构：透明度为100%，元素隐藏，占用空间</li><li>事件监听：可以进行DOM事件监听</li><li>性能：提升为合成层，不会触发重绘，性能较高</li><li>继承：会被子元素继承且子元素不能通过opacity: 1来取消隐藏</li><li>transition：opacity可以延时显示和隐藏</li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-组合总和</title>
      <link href="/2020/09/09/leetcode-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
      <url>/2020/09/09/leetcode-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的数字可以无限制重复被选取。</p><a id="more"></a><blockquote><p>原题描述访问：<a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations/</a><br>题解转自：<a href="https://leetcode-cn.com/problems/combination-sum/solution/shou-hua-tu-jie-zu-he-zong-he-combination-sum-by-x/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum/solution/shou-hua-tu-jie-zu-he-zong-he-combination-sum-by-x/</a></p></blockquote><p><strong>题意</strong><br>给你一个数组，里面都是不带重复的正数，还给你一个 target，求出所有和为 target 的组合。<br>元素可以重复使用，但组合不能重复，比如 [2, 2, 3] 与 [2, 3, 2] 是重复的。<br><strong>参考图解</strong><br><img src="https://cdn.jsdelivr.net/gh/yc2hang/cdn-assets/photos/combinationsum.png" alt="avatar"><br><strong>代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combinationSum = <span class="function">(<span class="params">candidates, target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">start, temp</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        res.push(temp.slice());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;  <span class="comment">// 结束当前递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; candidates.length; i++) &#123; <span class="comment">// 枚举出选择，从start开始</span></span><br><span class="line">      sum += candidates[i];     <span class="comment">// 累加给sum</span></span><br><span class="line">      temp.push(candidates[i]); <span class="comment">// 加入“部分解”</span></span><br><span class="line">      dfs(i, temp);             <span class="comment">// 往下递归，继续选择，注意是i，不是i+1</span></span><br><span class="line">      sum -= candidates[i];     <span class="comment">// 撤销选择，sum变回来</span></span><br><span class="line">      temp.pop();               <span class="comment">// 撤销选择</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dfs(<span class="number">0</span>, []);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><div class="note "><p>回溯：在包含问题的所有的解的空间树中，按DFS的方法，从根节点出发，搜索整棵解空间树。</p><p>搜索至任何一个节点时，总是会先判断当前节点是否可以 lead us to a complete solution。如果不可以，则结束对「以当前节点为根节点的子树」的搜索，向父节点回溯，回到之前的状态，搜索下一个分支。</p><p>否则，进入该子树，继续以DFS的方式搜索。</p><p>空间树中的节点是动态的，当前有哪些节点可选择，是根据上一步的选择（上一步的状态）得出的，所以做回溯时，要把状态还原成进入当前节点之前的状态。</p><p>我们在做题时，要确定出问题的解空间树，它是隐式的，不是显式的一棵树。不熟练的就画图看看。</p><p>然后，明确每个节点的扩展搜索规则。</p><p>然后进行DFS搜索，并注意剪枝，避免无效的搜索。</p></div>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> leetcode </tag>
            
            <tag> dfs </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-组合</title>
      <link href="/2020/09/09/leetcode-%E7%BB%84%E5%90%88/"/>
      <url>/2020/09/09/leetcode-%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><a id="more"></a><blockquote><p>原题描述访问：<a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations/</a></p></blockquote><h3 id="回溯剪枝"><a href="#回溯剪枝" class="headerlink" title="回溯剪枝"></a>回溯剪枝</h3><p>直接看代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combine = <span class="function">(<span class="params">n, k</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">start, path</span>) =&gt;</span> &#123; <span class="comment">// start是枚举选择的起点 path是当前构建的路径（组合）</span></span><br><span class="line">    <span class="keyword">if</span> (path.length == k) &#123;</span><br><span class="line">      res.push(path.slice());       <span class="comment">// 拷贝一份path，推入res</span></span><br><span class="line">      <span class="keyword">return</span>;                       <span class="comment">// 结束当前递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= n; i++) &#123; <span class="comment">// 枚举出所有选择</span></span><br><span class="line">      path.push(i);                    <span class="comment">// 选择</span></span><br><span class="line">      dfs(i + <span class="number">1</span>, path);             <span class="comment">// 向下继续选择</span></span><br><span class="line">      path.pop();                      <span class="comment">// 撤销选择</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  dfs(<span class="number">1</span>, []); <span class="comment">// 递归的入口，从数字1开始选</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> leetcode </tag>
            
            <tag> dfs </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-前k个高频元素</title>
      <link href="/2020/09/08/leetcode-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
      <url>/2020/09/08/leetcode-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><a id="more"></a><blockquote><p>原题描述访问：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></p></blockquote><h3 id="map-数组"><a href="#map-数组" class="headerlink" title="map+数组"></a>map+数组</h3><p>利用 map 记录每个元素出现的频率，利用数组来比较排序元素<br><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> topKFrequent = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(), arr = [...new <span class="built_in">Set</span>(nums)]</span><br><span class="line">    nums.map(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(num)) map.set(num, map.get(num)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span> map.set(num, <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> map.get(b) - map.get(a)).slice(<span class="number">0</span>, k);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(n)<br>题目要求算法的时间复杂度必须优于 O(n log n) ，所以这种实现不合题目要求</li></ul><h3 id="map-小顶堆"><a href="#map-小顶堆" class="headerlink" title="map+小顶堆"></a>map+小顶堆</h3><p>遍历一遍数组统计每个元素的频率，并将元素值（ key ）与出现的频率（ value ）保存到 map 中<br>通过 map 数据构建一个前 k 个高频元素小顶堆，小顶堆上的任意节点值都必须小于等于其左右子节点值，即堆顶是最小值。<br>具体步骤如下：<br>    - 遍历数据，统计每个元素的频率，并将元素值（ key ）与出现的频率（ value ）保存到 map 中<br>    - 遍历 map ，将前 k 个数，构造一个小顶堆<br>    - 从 k 位开始，继续遍历 map ，每一个数据出现频率都和小顶堆的堆顶元素出现频率进行比较，如果小于堆顶元素，则不做任何处理，继续遍历下一元素；如果大于堆顶元素，则将这个元素替换掉堆顶元素，然后再堆化成一个小顶堆。<br>    - 遍历完成后，堆中的数据就是前 k 大的数据<br><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> topKFrequent = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(), heap = [,]</span><br><span class="line">    nums.map(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(num)) map.set(num, map.get(num)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span> map.set(num, <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果元素数量小于等于 k</span></span><br><span class="line">    <span class="keyword">if</span>(map.size &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">return</span> [...map.keys()]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果元素数量大于 k，遍历map，构建小顶堆</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    map.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; k) &#123;</span><br><span class="line">            <span class="comment">// 取前k个建堆, 插入堆</span></span><br><span class="line">            heap.push(key)</span><br><span class="line">            <span class="comment">// 原地建立前 k 堆</span></span><br><span class="line">            <span class="keyword">if</span>(i === k<span class="number">-1</span>) buildHeap(heap, map, k)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(map.get(heap[<span class="number">1</span>]) &lt; value) &#123;</span><br><span class="line">            <span class="comment">// 替换并堆化</span></span><br><span class="line">            heap[<span class="number">1</span>] = key</span><br><span class="line">            <span class="comment">// 自上而下式堆化第一个元素</span></span><br><span class="line">            heapify(heap, map, k, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 删除heap中第一个元素</span></span><br><span class="line">    heap.shift()</span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原地建堆，从后往前，自上而下式建小顶堆</span></span><br><span class="line"><span class="keyword">let</span> buildHeap = <span class="function">(<span class="params">heap, map, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(k === <span class="number">1</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始，自上而下式堆化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(k/<span class="number">2</span>); i&gt;=<span class="number">1</span> ; i--) &#123;</span><br><span class="line">        heapify(heap, map, k, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆化</span></span><br><span class="line"><span class="keyword">let</span> heapify = <span class="function">(<span class="params">heap, map, k, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 自上而下式堆化</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> minIndex = i</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*i &lt;= k &amp;&amp; map.get(heap[<span class="number">2</span>*i]) &lt; map.get(heap[i])) &#123;</span><br><span class="line">            minIndex = <span class="number">2</span>*i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span> &lt;= k &amp;&amp; map.get(heap[<span class="number">2</span>*i+<span class="number">1</span>]) &lt; map.get(heap[minIndex])) &#123;</span><br><span class="line">            minIndex = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minIndex !== i) &#123;</span><br><span class="line">            swap(heap, i, minIndex)</span><br><span class="line">            i = minIndex</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换</span></span><br><span class="line"><span class="keyword">let</span> swap = <span class="function">(<span class="params">arr, i , j</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i]</span><br><span class="line">    arr[i] = arr[j]</span><br><span class="line">    arr[j] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：遍历数组需要 O(n) 的时间复杂度，一次堆化需要 O(logk) 时间复杂度，所以利用堆求 Top k 问题的时间复杂度为 O(nlogk)</li><li>空间复杂度：O(n)</li></ul><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>这里取前k个高频元素，使用计数排序不再适合，在上题目中使用计数排序，将 i 元素出现的次数存储在 bucket[i] ，但这种存储不能保证 bucket 数组上值是有序的，例如 bucket=[0,3,1,2] ，即元素 0 未出现，元素 1 出现 3 次，元素 2 出现 1 次，元素 3 出现 2 次，所以计数排序不适用于取前k个高频元素，不过，不用怕，计数排序不行，还有桶排序。</p><p>桶排序是计数排序的升级版。它也是利用函数的映射关系。</p><p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><ul><li>首先使用 map 来存储频率</li><li>然后创建一个数组（有数量的桶），将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标（桶内）即可。</li></ul><p><strong>代码实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> topKFrequent = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(), arr = [...new <span class="built_in">Set</span>(nums)]</span><br><span class="line">    nums.map(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(num)) map.set(num, map.get(num)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span> map.set(num, <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果元素数量小于等于 k</span></span><br><span class="line">    <span class="keyword">if</span>(map.size &lt;= k) &#123;</span><br><span class="line">        <span class="keyword">return</span> [...map.keys()]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bucketSort(map, k)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="keyword">let</span> bucketSort = <span class="function">(<span class="params">map, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [], res = []</span><br><span class="line">    map.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 利用映射关系（出现频率作为下标）将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">if</span>(!arr[value]) &#123;</span><br><span class="line">            arr[value] = [key]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[value].push(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 倒序遍历获取出现频率最大的前k个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.length - <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; res.length &lt; k;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]) &#123;</span><br><span class="line">            res.push(...arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map </tag>
            
            <tag> 小顶堆 </tag>
            
            <tag> 桶排序 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖和节流</title>
      <link href="/2020/09/07/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
      <url>/2020/09/07/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>前端开发中，我们的一些事件的响应比较慢或者需要请求接口完成的，我们不希望这些事件频繁执行，比如说需要对input输入的数据保存，监听keyup事件，如果每次键盘输入就执行保存请求，那样可能会产生很多频繁的请求，针对这种连续触发的高频率事件，函数防抖和函数节流给出了两种解决方法</p><a id="more"></a><h3 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h3><div class="note "><p>去抖动，方法是在函数触发时，设定一个周期延迟执行函数，若在周期内函数再次执行、则刷新延迟时间，直到最后执行函数，这里函数收集到的结果是最后一次操作的结果</p></div><h5 id="简单的实现"><a href="#简单的实现" class="headerlink" title="简单的实现"></a>简单的实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer; <span class="comment">// 定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.target.value);</span><br><span class="line">        timer = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#test"</span>).addEventListener(<span class="string">'keyup'</span>, change);</span><br></pre></td></tr></table></figure><p>这里监听input的keyup事件，change方法执行的时候会首先判断定时器是否存在、如果存在则clear掉，如果不则新建一个定时器延迟1s执行</p><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>上面这样实现没毛病，但是却有一个问题，没有复用性,现在我来把他封装成一个公共的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">keyup</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">method, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timer = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        timer &amp;&amp; clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            method.apply(self, args)</span><br><span class="line">            timer = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#test"</span>).addEventListener(<span class="string">'keyup'</span>, debounce(keyup, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure><h3 id="节流-throttling"><a href="#节流-throttling" class="headerlink" title="节流(throttling)"></a>节流(throttling)</h3><div class="note "><p>节流的概念是设定一个周期，周期内只执行一次，若有新的事件触发则不执行，周期结束后又有新的事件触发开始新的周期</p></div><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>比如说我们监听onscroll判断获取当前的scrollTop、可以用到节流</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start, timer, wait = <span class="number">200</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">        <span class="comment">//第一次触发，设置start时间</span></span><br><span class="line">        start = <span class="built_in">Date</span>.now()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前时间减去开始时间大于等于设定的周期则执行并且初始化start、timer</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Date</span>.now() - start &gt;= wait) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'触发了'</span>)</span><br><span class="line">        start = timer = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        timer &amp;&amp; clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            scroll.apply(self, <span class="built_in">arguments</span>)</span><br><span class="line">        &#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, scroll)</span><br></pre></td></tr></table></figure><h5 id="封装-1"><a href="#封装-1" class="headerlink" title="封装"></a>封装</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttling</span> (<span class="params">method, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start, timer</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">            start = <span class="built_in">Date</span>.now();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Date</span>.now() - start &gt;= wait) &#123;</span><br><span class="line">            method.apply(self, args)</span><br><span class="line">            start = timer = <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timer &amp;&amp; clearTimeout(timer)</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                run.apply(self, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scroll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'触发了'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, throttling(scroll, <span class="number">200</span>))</span><br></pre></td></tr></table></figure><div class="note "><ul><li>防抖和节流，通俗来说就是，函数防抖的时候,每次调用事件都是在正常执行暂停后一段时间(等你歇菜了我再上) 函数节流的时候,则是每隔一定的时间间隔就触发一次(管你频率那么快,我就保持自己的节奏) </li><li>防抖：在设定时间间隔内，再次触发事件时，定时器会清除，函数重新执行</li><li>节流：在设定时间间隔内，再次触发事件时，判断定时器是否为null，若为null，则执行函数。否则不执行</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS的执行机制</title>
      <link href="/2020/09/07/JS%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/09/07/JS%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>网上很多js机制相关的讲解，本篇只列出相关题目以便以后复习巩固</p><a id="more"></a><div class="note "><p>js执行机制相关讲解可参考以下博客<br><a href="https://juejin.im/post/6855129007558492174" target="_blank" rel="noopener">https://juejin.im/post/6855129007558492174</a><br><a href="https://juejin.im/post/6844903568814800904" target="_blank" rel="noopener">https://juejin.im/post/6844903568814800904</a></p></div><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>任务队列就是一个事件队列,我们前面提到的有些耗时的任务或一些异步任务,我们将它放到任务队列中.当满足某些条件时就可以从任务队列中取出去放到主线程中执行. 我们先来看下面的代码,类似的问题是有可能出现在一些面试题中的.问的就是打印出来的顺序是多少?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2 3 4 1</span></span><br></pre></td></tr></table></figure><p>为什么是 2341 的顺序呢?我们来分析下,JS中代码的执行是从上到下一行一行执行的.首先执行的是 setTimeout 这段代码,发现这是定时器任务,于是便把内部的具体执行内容 console.log(1) 先拿出来放到其他地方,准备待会儿再执行.继续执行到 console.log(2) 这句,于是先输出一个2.继续执行,遇到了一个 Promise .注意在这个 Promise中 , console.log(3) 以及之后的 resolve() 这两句都是同步执行的,但是 then 里面的代码却是异步执行的.于是在输出了一个3之后,又把 console.log(4) 拿出来放到其他地方,准备晚点再去执行它.好了,现在我们已经把 console.log(1) 和 console.log(4) 扔进了一个地方,那么为什么是先输出4然后再是1呢?这是因为虽然1和4都被我们扔进了一个地方,我们可以把这个地方理解为一个大房子.1和4被扔进了不同的房间.其中1被扔进了一个叫做 宏任务队列 的房间.4被扔进了另一个叫做 微任务队列 的房间.</p><p><strong>总结起来就是:</strong>不同类型的任务会进入到对应的事件队列(Event Queue)中.每次执行下一个宏任务之前先去微任务队列里面查看,直到把微任务队列清空后再去执行宏任务队列中的任务.</p><h3 id="微任务和宏任务"><a href="#微任务和宏任务" class="headerlink" title="微任务和宏任务"></a>微任务和宏任务</h3><ul><li><strong>微任务(micro-task)</strong>: Promise ,process.nextTick 等</li><li><strong>宏任务(macro-task)</strong>: script, setTimeout, setInterval 等</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 2 1 3</span></span><br></pre></td></tr></table></figure><p>可以看到输出的结果为 2 1 3 ,这就是因为 setTimeout 是个宏任务, 而 nextTick 则是个微任务.所以先清空微任务队列,即先执行 process.nextTick 的回调.</p><h3 id="运用微任务和宏任务来解题"><a href="#运用微任务和宏任务来解题" class="headerlink" title="运用微任务和宏任务来解题"></a>运用微任务和宏任务来解题</h3><p>到这里我们已经介绍了同步异步以及微任务队列和宏任务队列的相关内容了,我们再来看一看一道复杂一点的题目.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">9</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 4 5 7 6 9 1 2 3 8</span></span><br></pre></td></tr></table></figure><p>首先执行前面两个 setTimeout ,于是把123放到了宏任务队列中.执行到4的时候,先打印出一个4.然后是两个Promise,先打印出5,然后把6放到了微任务队列中.再之后打印出7,把8放到宏任务中,然后就是9放到微任务中.此时已经打印出457,并且微任务中有[6,9],宏任务中有[1,2,3,8].代码第一遍已经执行完毕,前面提到了整个script 脚本相当于一个宏任务.于是便去执行微任务,接着打印出69.此时微任务已经清空,去执行宏任务.选取宏任务队列中的第一个任务,打印出1之后.回过头去看看微任务队列是否还有未执行的任务,现在已经没有了.于是便继续执行宏任务队列中的下一个任务即2.打印出2之后,因为这是一个 Promise ,所以将then里面的3放到微任务队列,此次宏任务执行完毕.此时的微任务队列有[3],宏任务队列有[8].再去执行微任务队列,打印出3.最后再次执行宏任务队列,打印出8.</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2020/09/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2020/09/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>目前经典的排序算法包括(冒泡排序，选择排序，插入排序)，合并排序和快速排序，其中效率最高的为快速排序，以下为详细讲解</p><a id="more"></a><div class="note "><p>转自阮一峰博客：<a href="https://javascript.ruanyifeng.com/library/sorting.html" target="_blank" rel="noopener">https://javascript.ruanyifeng.com/library/sorting.html</a><br>参考：<a href="https://humanwhocodes.com/blog/2012/11/27/computer-science-in-javascript-quicksort/" target="_blank" rel="noopener">https://humanwhocodes.com/blog/2012/11/27/computer-science-in-javascript-quicksort/</a></p></div><p><img src="https://cdn.jsdelivr.net/gh/yc2hang/cdn-assets/photos/sort.jpg" alt="avatar"></p><h3 id="尼古拉斯·泽卡斯版"><a href="#尼古拉斯·泽卡斯版" class="headerlink" title="尼古拉斯·泽卡斯版"></a>尼古拉斯·泽卡斯版</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>快速排序（quick sort）是公认最快的排序算法之一，有着广泛的应用。</p><p>它的基本思想很简单：先确定一个“支点”（pivot），将所有小于“支点”的值都放在该点的左侧，大于“支点”的值都放在该点的右侧，然后对左右两侧不断重复这个过程，直到所有排序完成。</p><p>具体做法是：</p><div class="note info"><ol><li>确定“支点”（pivot）。虽然数组中任意一个值都能作为“支点”，但通常是取数组的中间值。</li><li>建立两端的指针。左侧的指针指向数组的第一个元素，右侧的指针指向数组的最后一个元素。</li><li>左侧指针的当前值与“支点”进行比较，如果小于“支点”则指针向后移动一位，否则指针停在原地。</li><li>右侧指针的当前值与“支点”进行比较，如果大于“支点”则指针向前移动一位，否则指针停在原地。</li><li>左侧指针的位置与右侧指针的位置进行比较，如果前者大于等于后者，则本次排序结束；否则，左侧指针的值与右侧指针的值相交换。</li><li>对左右两侧重复第2至5步。</li></ol></div><p>以对数组[3, 2, 4, 5, 1] 进行从小到大排序为例，步骤如下：</p><div class="note info"><ol><li>选择中间值“4”作为“支点”。</li><li>第一个元素3小于4，左侧指针向后移动一位；第二个元素2小于4，左侧指针向后移动一位；第三个元素4等于4，左侧指针停在这个位置（数组的第2位）。</li><li>倒数第一个元素1小于4，右侧指针停在这个位置（数组的第4位）。</li><li>左侧指针的位置（2）小于右侧指针的位置（4），两个位置的值互换，数组变成[3, 2, 1, 5, 4]。</li><li>左侧指针向后移动一位，第四个元素5大于4，左侧指针停在这个位置（数组的第3位）。</li><li>右侧指针向前移动一位，第四个元素5大于4，右侧指针移动向前移动一位，第三个元素1小于4，右侧指针停在这个位置（数组的第3位）。</li><li>左侧指针的位置（3）大于右侧指针的位置（2），本次排序结束。</li><li>对 [3, 2, 1]和[5, 4]两部分各自不断重复上述步骤，直到排序完成。</li></ol></div><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>首先部署一个swap函数，用于互换两个位置的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">myArray, firstIndex, secondIndex</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = myArray[firstIndex];</span><br><span class="line">    myArray[firstIndex] = myArray[secondIndex];</span><br><span class="line">    myArray[secondIndex] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，部署一个partition函数，用于完成一轮排序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">myArray, left, right</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pivot   = myArray[<span class="built_in">Math</span>.floor((right + left) / <span class="number">2</span>)],</span><br><span class="line">        i       = left,</span><br><span class="line">        j       = right;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (myArray[i] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (myArray[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">            swap(myArray, i, j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就是递归上面的过程，完成整个排序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">myArray, left, right</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myArray.length &lt; <span class="number">2</span>) <span class="keyword">return</span> myArray;</span><br><span class="line"></span><br><span class="line">left = (<span class="keyword">typeof</span> left !== <span class="string">"number"</span> ? <span class="number">0</span> : left);</span><br><span class="line"></span><br><span class="line">right = (<span class="keyword">typeof</span> right !== <span class="string">"number"</span> ? myArray.length - <span class="number">1</span> : right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index  = partition(myArray, left, right);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (left &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">            quickSort(myArray, left, index - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (index &lt; right) &#123;</span><br><span class="line">            quickSort(myArray, index, right);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> myArray;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阮一峰版"><a href="#阮一峰版" class="headerlink" title="阮一峰版"></a>阮一峰版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;<span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> left = []</span><br><span class="line">    <span class="keyword">let</span> right = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</span><br><span class="line">            left.push(arr[i])</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单好记版（ES6）"><a href="#简单好记版（ES6）" class="headerlink" title="简单好记版（ES6）"></a>简单好记版（ES6）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!arr || arr.length&lt;<span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line">    <span class="keyword">let</span> pivot = arr.shift()</span><br><span class="line">    <span class="keyword">let</span> left = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &lt; pivot)</span><br><span class="line">    <span class="keyword">let</span> right = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item&gt;=pivot)</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树解题总结</title>
      <link href="/2020/09/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2020/09/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A7%A3%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>二叉树是实现递归的经典数据结构，关于二叉树的解题套路请看下文</p><a id="more"></a><p>二叉树算法的设计的总路线：明确一个节点要做的事情，然后剩下的事抛给框架。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> traverse(TreeNode root) &#123;</span><br><span class="line">    <span class="comment">// root 需要做什么？在这做。</span></span><br><span class="line">    <span class="comment">// 其他的不用 root 操心，抛给框架</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. 如何把二叉树所有的节点中的值加一？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> plusOne(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    root.val += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    plusOne(root.left);</span><br><span class="line">    plusOne(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 如何判断两棵二叉树是否完全相同？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">boolean isSameTree(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">    <span class="comment">// 都为空的话，显然相同</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 一个为空，一个非空，显然不同</span></span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> || root2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 两个都非空，但 val 不一样也不行</span></span><br><span class="line">    <span class="keyword">if</span> (root1.val != root2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// root1 和 root2 该比的都比完了</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(root1.left, root2.left)</span><br><span class="line">        &amp;&amp; isSameTree(root1.right, root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 零、判断 BST 的合法性</strong><br>这里是有坑的哦，我们按照刚才的思路，每个节点自己要做的事不就是比较自己和左右孩子吗？看起来应该这样写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.val &lt;= root.left.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.val &gt;= root.right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left)</span><br><span class="line">        &amp;&amp; isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个算法出现了错误，BST 的每个节点应该要小于右边子树的所有节点，下面这个二叉树显然不是 BST，但是我们的算法会把它判定为 BST。<br>我们重新看一下 BST 的定义，root 需要做的不只是和左右子节点比较，而是要整个左子树和右子树所有节点比较。<br>这种情况，我们可以使用辅助函数，增加函数参数列表，在参数中携带额外信息，请看正确的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (min != <span class="literal">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max != <span class="literal">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root) </span><br><span class="line">        &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 在 BST 中查找一个数是否存在</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BST(TreeNode root, int target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == target)</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; target) </span><br><span class="line">        BST(root.right, target);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; target)</span><br><span class="line">        BST(root.left, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 在 BST 中插入一个数</strong><br>对数据结构的操作无非遍历 + 访问，遍历就是“找”，访问就是“改”。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。<br>上一个问题，我们总结了 BST 中的遍历框架，就是“找”的问题。直接套框架，加上“改”的操作即可。一旦涉及“改”，函数就要返回 TreeNode 类型，并且对递归调用的返回值进行接收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeNode insertIntoBST(TreeNode root, int val) &#123;</span><br><span class="line">    <span class="comment">// 找到空位置插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="comment">// if (root.val == val)</span></span><br><span class="line">    <span class="comment">//     BST 中一般不会插入已存在元素</span></span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; val) </span><br><span class="line">        root.right = insertIntoBST(root.right, val);</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val) </span><br><span class="line">        root.left = insertIntoBST(root.left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6. 在 BST 中删除一个数</strong><br>这个问题稍微复杂，不过你有框架指导，难不住你。跟插入操作类似，先“找”再“改”，先把框架写出来再说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TreeNode deleteNode(TreeNode root, int key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">        <span class="comment">// 找到啦，进行删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到目标节点了，比方说是节点 A，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。</p><ol><li>情况 1：A 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li>情况 2：A 只有一个非空子节点，那么它要让这个孩子接替自己的位置。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排除了情况 1 之后</span></span><br><span class="line"><span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line"><span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br></pre></td></tr></table></figure></li><li>情况 3：A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">    TreeNode minNode = getMin(root.right);</span><br><span class="line">    <span class="comment">// 把 root 改成 minNode</span></span><br><span class="line">    root.val = minNode.val;</span><br><span class="line">    <span class="comment">// 转而去删除 minNode</span></span><br><span class="line">    root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>简化代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TreeNode deleteNode(TreeNode root, int key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">        <span class="comment">// 这两个 if 把情况 1 和 2 都正确处理了</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="comment">// 处理情况 3</span></span><br><span class="line">        TreeNode minNode = getMin(root.right);</span><br><span class="line">        root.val = minNode.val;</span><br><span class="line">        root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">        root.left = deleteNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">        root.right = deleteNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode getMin(TreeNode node) &#123;</span><br><span class="line">    <span class="comment">// BST 最左边的就是最小的</span></span><br><span class="line">    <span class="keyword">while</span> (node.left != <span class="literal">null</span>) node = node.left;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：本文章来源自作者labuladong</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-二叉树的层次遍历</title>
      <link href="/2020/09/06/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
      <url>/2020/09/06/leetcode-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><a id="more"></a><blockquote><p>原题描述访问：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p></blockquote><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><p>首先定义一个存储结果的数组，将二叉树的每一层分级lv，遍历每个跟节点，将节点的值存入数组，遍历一层lv+1，递归左右子节点将值存入同级数组中，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || root.length === <span class="number">0</span>) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">let</span> bfs = <span class="function">(<span class="params">curr, lv</span>) =&gt;</span> &#123;</span><br><span class="line">        !res[lv] &amp;&amp; (res[lv] = [])</span><br><span class="line">        <span class="keyword">if</span>(curr)&#123;</span><br><span class="line">            res[lv].push(curr.val)</span><br><span class="line">            <span class="keyword">if</span>(curr.left) bfs(curr.left, lv+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span>(curr.right) bfs(curr.right, lv+<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bfs(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>将初始二叉树存入quene中，通过双层while循环存入每层级的值</p><ul><li>外层while循环的是二叉树每层的数量</li><li>内层while目的是将每层的每项存入各层数组中</li></ul><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root || root.length === <span class="number">0</span>) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">var</span> result = []</span><br><span class="line">    <span class="keyword">var</span> quene = [root]</span><br><span class="line">    <span class="keyword">while</span>(quene.length)&#123;</span><br><span class="line">        <span class="keyword">var</span> len = quene.length</span><br><span class="line">        <span class="keyword">var</span> layer = []</span><br><span class="line">        <span class="keyword">while</span>(len)&#123;</span><br><span class="line">            <span class="keyword">var</span> node = quene.shift()</span><br><span class="line">            layer.push(node.val)</span><br><span class="line">            <span class="keyword">if</span>(node.left)&#123;</span><br><span class="line">                quene.push(node.left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right)&#123;</span><br><span class="line">                quene.push(node.right)</span><br><span class="line">            &#125;</span><br><span class="line">            len--</span><br><span class="line">        &#125;</span><br><span class="line">        result.push(layer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 递归 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见面试题</title>
      <link href="/2020/09/06/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/09/06/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>常见面试题汇总</p><a id="more"></a><ol><li>手写一个sleep函数（可从Promise，Generator，async/await等角度实现）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        setTimeout(resolve, ms)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">~<span class="function">(<span class="params"><span class="keyword">async</span> (</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">2000</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">222</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li>已知如下数组，编写一个程序将数组扁平化去除其中重复部分数据，最终得到一个升序且不重复的数组(不使用es6的flat()方法)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>]]]], <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> arr[i] == <span class="string">'number'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.indexOf(arr[i]) == <span class="number">-1</span>)&#123;</span><br><span class="line">                res.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            flat(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pivot = res[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> left = [],right = []</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]&gt;pivot)&#123;</span><br><span class="line">            right.push(res[i])</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res[i]&lt;pivot)&#123;</span><br><span class="line">            left.push(res[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(left.concat(pivot, right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flat(arr)</span><br></pre></td></tr></table></figure></li><li>在不改变当前代码的情况下，使这张图片的宽度为300px <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.png"</span> <span class="attr">style</span>=<span class="string">"width: 480px !important"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>css方法<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.png"</span> <span class="attr">style</span>=<span class="string">"width: 480px !important; max-width: 300px "</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.png"</span> <span class="attr">style</span>=<span class="string">"width: 480px !important; transform: scale(0.65, 1);"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"1.png"</span> <span class="attr">style</span>=<span class="string">"width: 480px !important; width: 300px !important"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li>js方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)[<span class="number">0</span>].setAttribute(<span class="string">'style'</span>, <span class="string">'width: 300px !important'</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS连等运算</title>
      <link href="/2020/09/06/JS%E8%BF%9E%E7%AD%89%E8%BF%90%E7%AE%97/"/>
      <url>/2020/09/06/JS%E8%BF%9E%E7%AD%89%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>js连等运算知识点考查</p><a id="more"></a><ul><li><p>输出以下代码的结果并解释为什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125; <span class="comment">// a = &#123; n: 2 &#125; =&gt; &#123; n: 2 &#125;.x = a</span></span><br><span class="line"><span class="built_in">console</span>.log(a.x) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x) <span class="comment">// &#123; n: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>解释：这里的重点是a.x到底是谁<br>简单来说，在赋值过程开始时，a其实是{n:1}<br>a.x=a={n:2}<br>其实在计算机眼中是长成这样的：<br>{n:1}.x=a={n:2}<br>所以，这个赋值发生了两件事<br>//1.把”a”变成了{n:2}<br>//2.把{n:1}的x变成了{n:2}——————–<br>也就是说：<br>a.x = a = {n: 2};<br>其实被计算机执行成了<br>{n:1}.x={n: 2};<br>a={n: 2};<br>所以最后的结果变成了<br>a=={n: 2};<br>console.log(a.x) =&gt; undefined    //因为a没有x属性<br>b=={n: 1, x: {n: 2}}<br>console.log(b.x) =&gt; {n: 2}</p></li><li><p>连等开始之前，程序会把所有引用都保存起来</p></li><li><p>连等的过程中，这些值是不变的</p></li><li><p>等到整个连等结束了，再一起变</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域常用解决方案</title>
      <link href="/2020/09/06/%E8%B7%A8%E5%9F%9F%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2020/09/06/%E8%B7%A8%E5%9F%9F%E5%B8%B8%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>在前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能同源使用的限制。</p><a id="more"></a><h3 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h3><div class="note "><p>同源策略是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p></div><h5 id="同源策略限制以下几种行为："><a href="#同源策略限制以下几种行为：" class="headerlink" title="同源策略限制以下几种行为："></a>同源策略限制以下几种行为：</h5><ul><li>Cookie、LocalStorage 和 IndexDB 无法读取</li><li>DOM和JS对象无法获得</li><li>AJAX 请求不能发送</li></ul><h3 id="常见跨域解决方案"><a href="#常见跨域解决方案" class="headerlink" title="常见跨域解决方案"></a>常见跨域解决方案</h3><h4 id="1-JSONP跨域"><a href="#1-JSONP跨域" class="headerlink" title="1. JSONP跨域"></a>1. JSONP跨域</h4><p>jsonp的原理就是利用script标签没有跨域限制，通过script标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p><ul><li>原生JS实现<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">    script.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span></span><br><span class="line"><span class="actionscript">    script.src = <span class="string">'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.head.appendChild(script);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 回调执行函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">handleCallback</span><span class="params">(res)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="built_in">JSON</span>.stringify(res));</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>服务端返回如下（返回时即执行全局函数）：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleCallback(&#123;<span class="string">"success"</span>: <span class="literal">true</span>, <span class="string">"user"</span>: <span class="string">"admin"</span>&#125;)</span><br></pre></td></tr></table></figure></li><li>后端node实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> params = querystring.parse(req.url.split(<span class="string">'?'</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> fn = params.callback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jsonp返回设置</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/javascript'</span> &#125;);</span><br><span class="line">    res.write(fn + <span class="string">'('</span> + <span class="built_in">JSON</span>.stringify(params) + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure><div class="note "><p>jsonp的缺点：只能发送get一种请求。 </p></div></li></ul><h4 id="2-跨域资源共享-CORS"><a href="#2-跨域资源共享-CORS" class="headerlink" title="2. 跨域资源共享(CORS)"></a>2. 跨域资源共享(CORS)</h4><div class="note "><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p></div><p>浏览器将CORS跨域请求分为简单请求和非简单请求。只要同时满足一下两个条件，就属于简单请求</p><ol><li>使用下列方法之一<ul><li>head</li><li>get</li><li>post</li></ul></li><li>请求的Heder是<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type: 只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul></li></ol><p>不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。</p><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0...</span><br></pre></td></tr></table></figure><p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br><strong>CORS请求设置的响应头字段，都以 Access-Control-开头:</strong></p><ul><li><strong>Access-Control-Allow-Origin</strong>：必选</li><li><strong>Access-Control-Allow-Credentials</strong>：可选</li><li><strong>Access-Control-Expose-Headers</strong>：可选</li></ul><h5 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h5><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<br><strong>预检请求</strong><br>预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。请求头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0..</span><br></pre></td></tr></table></figure><ul><li>原生JS实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'post'</span>, <span class="string">'http://www.domain2.com:8080/login'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</span><br><span class="line">xhr.send(<span class="string">'user=admin'</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>后端node代码<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> postData = <span class="string">''</span>;</span><br><span class="line">    <span class="comment">// 数据块接收中</span></span><br><span class="line">    req.addListener(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 数据接收完毕</span></span><br><span class="line">    req.addListener(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line">        <span class="comment">// 跨域后台设置</span></span><br><span class="line">        res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">'Access-Control-Allow-Credentials'</span>: <span class="string">'true'</span>,     <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">            <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'http://www.domain1.com'</span>,    <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span></span><br><span class="line"><span class="comment">             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="string">'Set-Cookie'</span>: <span class="string">'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>  <span class="comment">// HttpOnly的作用是让js无法读取cookie</span></span><br><span class="line">        &#125;);</span><br><span class="line">        res.write(<span class="built_in">JSON</span>.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="string">'8080'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running at port 8080...'</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-nginx代理跨域"><a href="#3-nginx代理跨域" class="headerlink" title="3. nginx代理跨域"></a>3. nginx代理跨域</h4><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p><ol><li>nginx配置解决iconfont跨域<br>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>nginx反向代理接口跨域<div class="note "><p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p></div></li></ol><h4 id="4-nodejs中间件代理跨域"><a href="#4-nodejs中间件代理跨域" class="headerlink" title="4. nodejs中间件代理跨域"></a>4. nodejs中间件代理跨域</h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。<br><strong>vue框架的跨域</strong><br>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。<br>webpack.config.js部分配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: <span class="string">'/login'</span>,</span><br><span class="line">            target: <span class="string">'http://www.domain2.com:8080'</span>,  <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">            changeOrigin: <span class="literal">true</span>,</span><br><span class="line">            secure: <span class="literal">false</span>,  <span class="comment">// 当代理某些https服务报错时用</span></span><br><span class="line">            cookieDomainRewrite: <span class="string">'www.domain1.com'</span>  <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>声明：以上内容转自<a href="https://segmentfault.com/a/1190000011145364" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011145364</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回流和重绘</title>
      <link href="/2020/09/05/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/"/>
      <url>/2020/09/05/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/</url>
      
        <content type="html"><![CDATA[<p>网页的回流和重绘知识点如下：</p><a id="more"></a><ol><li><strong>回流</strong><br>回流又称之为<strong>重排</strong>，当Render Tree中的一部分（或者全部）因元素的规模，尺寸，布局等改变，而需要重新构建页面，就会触发回流<br>具体总结为：<ul><li>页面初始渲染</li><li>添加、删除可见的DOM元素</li><li>改变元素位置，尺寸，内容<br>触发回流的属性：</li><li>盒子模型相关属性：width、height、display、border、border-width…</li><li>定位及浮动：position、left、right、top、bottom、float、padding、margin…</li><li>文字相关：text-align、overflow、font-weight、font-family、line-height，vertical-align、font-size、white-space…</li></ul></li><li><strong>重绘</strong><br>当Render Tree中的一些元素需要更新属性，而这些属性只是影响到元素的外观，风格而不影响布局，就会触发重绘<br><strong>回流一定重绘，但是重绘不一定回流</strong><br>触发重绘的属性：<ul><li>color、border-style、border-radius、outline、visibility、background-color、text-decoration、background、background-image、box-shadow…</li></ul></li><li>如何减少回流和重绘<ul><li>用translate代替top</li><li>用opacity代替visibility</li><li>预先定义好className，然后统一修改Dom的className</li><li>不要把Dom结点的属性值放在一个循环里面变成循环变量</li><li>让要操作的元素进行“离线处理”，处理完后一起更新</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>undefined和null</title>
      <link href="/2020/09/05/undefined%E5%92%8Cnull/"/>
      <url>/2020/09/05/undefined%E5%92%8Cnull/</url>
      
        <content type="html"><![CDATA[<p>undefined和null出现场景总结如下：</p><a id="more"></a><ul><li><strong>undefined</strong><ul><li>变量提升：只声明，未定义，其默认值为undefined</li><li>严格模式下，没有明确的执行主体，this的值为undefined</li><li>对象没有这个属性名，属性值为undefined</li><li>对象没有这个属性名，typeof obj[item]值为字符串’undefined’</li><li>函数定义形参不传值，默认值为undefined</li><li>函数没有返回值（没有return语句或者return;）</li><li>…</li></ul></li><li><strong>null</strong><ul><li>手动设置变量的值或者对象某一属性的值为null（后面再赋值）</li><li>在JS的DOM元素获取中，如果没有获取到指定的元素对象，结果一般为null</li><li>Object.prototype._proto_的值为null</li><li>正则捕获的时候，如果没有捕获到结果，默认值是null</li><li>…</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何实现数组去重</title>
      <link href="/2020/09/05/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
      <url>/2020/09/05/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<p>实现数组去重有多种方式实现，具体可见如下代码：</p><a id="more"></a><ol><li>循环迭代+map<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">~(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pro = <span class="built_in">Array</span>.prototype</span><br><span class="line">    pro.myDistinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> item = <span class="keyword">this</span>[i]</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> obj[item] !== <span class="string">'undefined'</span>)&#123; <span class="comment">// 括号中也可写做 obj[item] !== undefined</span></span><br><span class="line">                <span class="keyword">this</span>[i] = <span class="keyword">this</span>[<span class="keyword">this</span>.length<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">this</span>.length--</span><br><span class="line">                i--</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            obj[item] = item</span><br><span class="line">        &#125;</span><br><span class="line">        obj = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li>ES6的Array.filter()<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pro = <span class="built_in">Array</span>.prototype</span><br><span class="line">    pro.myDistinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(item) === index</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li>ES6的Set()（高性能）<br>set结构成员的值都是唯一的，可以接受数组作为参数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pro = <span class="built_in">Array</span>.prototype</span><br><span class="line">    pro.myDistinct = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">set</span> = new Set(this)</span><br><span class="line">        return [...<span class="keyword">set</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多个按钮单击事件</title>
      <link href="/2020/09/05/%E5%A4%9A%E4%B8%AA%E6%8C%89%E9%92%AE%E5%8D%95%E5%87%BB%E4%BA%8B%E4%BB%B6/"/>
      <url>/2020/09/05/%E5%A4%9A%E4%B8%AA%E6%8C%89%E9%92%AE%E5%8D%95%E5%87%BB%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>关于多个按钮单击弹出结果面试题考察分析如下：</p><a id="more"></a><ul><li><p>题目部分代码片段如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btnBox = <span class="built_in">document</span>.getElementById(<span class="string">'btnBox'</span>)</span><br><span class="line"><span class="keyword">var</span> inputs = btnBox.getElementsByTagName(<span class="string">'input'</span>)</span><br><span class="line"><span class="keyword">var</span> l = inputs.length</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;l;i++)&#123; <span class="comment">// 点击时候循环已结束， i = 5</span></span><br><span class="line">    inputs[i].click = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上题目涉及到如下知识</p><ul><li><strong>所有的事件绑定都是异步编程</strong>（绑定的时候方法并没有执行），当点击触发的时候，循环早已经结束<ul><li>同步：Js中当前任务没有完成，之后的任务不会执行</li><li>异步：Js中当前任务没有完成，可以继续执行其他任务</li></ul></li></ul></li><li><p>三种解决方案如下：</p><ol><li>自定义属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">    inputs[i].MyIndex = i</span><br><span class="line">    inputs[i].click = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>..MyIndex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>闭包<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">    ~(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        inputs[i].click = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>..MyIndex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法, 形成多个不销毁的闭包，性能不好</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">    inputs[i].click = (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>ES6（块级作用域）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">    inputs[i].click = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型和原型链</title>
      <link href="/2020/09/04/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2020/09/04/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>关于原型和原型链的考查部分题目如下：</p><a id="more"></a><ul><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">100</span></span><br><span class="line">    <span class="keyword">this</span>.y = <span class="number">200</span></span><br><span class="line">    <span class="keyword">this</span>.getX = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype = &#123; <span class="comment">// 批量扩展原型会改变Fn的constructor指向</span></span><br><span class="line">    y: <span class="number">400</span>,</span><br><span class="line">    getX = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">    &#125;,</span><br><span class="line">    getY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.y)</span><br><span class="line">    &#125;,</span><br><span class="line">    sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x + <span class="keyword">this</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Fn</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> Fn</span><br><span class="line"><span class="built_in">console</span>.log(f1.getX === f2.getX) <span class="comment">// 均为私有 false</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.getY === f2.getY) <span class="comment">// 公有getY true </span></span><br><span class="line"><span class="built_in">console</span>.log(f1.__proto__.getY === Fn.prototype.getY) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.__proto__.getX === f2.getX) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.getX === Fn.prototype.getX) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f1.constructor) <span class="comment">// Object</span></span><br><span class="line"><span class="built_in">console</span>.log(Fn.prototype.__proto__.constructor) <span class="comment">// Object</span></span><br><span class="line">f1.getX() <span class="comment">// this: f1, f1.x =&gt; 100 </span></span><br><span class="line">f1.__proto__.getX() <span class="comment">// this: f1.__proto(Fn.prototype) =&gt; Fn.prototype.x =&gt; undefined</span></span><br><span class="line">Fn.prototype.getY() <span class="comment">// this: Fn.prototype =&gt; Fn.prototype.y = 400</span></span><br><span class="line">f1.sum() <span class="comment">// this: f1 =&gt; f1.x+f1.y = 100 + 200 = 300</span></span><br><span class="line">Fn.prototype.sum() <span class="comment">// this: Fn.prototype =&gt; undefined + 400 = Nan</span></span><br></pre></td></tr></table></figure>根据题意，可画原型图如下所示：<br><img src="https://cdn.jsdelivr.net/gh/yc2hang/cdn-assets/photos/prototype.png" alt="avatar"></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包的考查</title>
      <link href="/2020/09/04/%E9%97%AD%E5%8C%85%E7%9A%84%E8%80%83%E6%9F%A5/"/>
      <url>/2020/09/04/%E9%97%AD%E5%8C%85%E7%9A%84%E8%80%83%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>关于闭包的考查部分题目如下：</p><a id="more"></a><p>首先抛出一个问题</p><ul><li>你理解的闭包是什么？优缺点有哪些？<ol><li>保护： 形成一个私有作用域，保护里面私有变量不受外界干扰</li><li>保存： 形成一个不销毁的栈内存，把所需要的变量保存起来以便后续使用</li></ol><ul><li>缺点： 形成不销毁的栈内存，比较耗性能</li></ul></li></ul><ol><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">12</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">13</span> <span class="comment">// 若此处去掉var，则答案选A</span></span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A、undefined, 12, 13</span></span><br><span class="line"><span class="comment"> * B、undefined, undefined, 12</span></span><br><span class="line"><span class="comment"> * C、undefined, undefined, 13</span></span><br><span class="line"><span class="comment"> * D、有程序报错</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 答案选B</span></span><br><span class="line"><span class="comment"> * 1，变量提升</span></span><br><span class="line"><span class="comment"> * 2，顺序执行</span></span><br><span class="line"><span class="comment"> * 3，执行fn，形成一个私有作用域=》形参赋值，变量提升，顺序执行</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure></li><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!foo)&#123; <span class="comment">// 不管条件是否成立，都要进行变量提示</span></span><br><span class="line">        <span class="keyword">var</span> foo = <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(foo)</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 答案选B 变量提升后foo= undefined，条件为true</span></span><br><span class="line"><span class="comment"> * A、1</span></span><br><span class="line"><span class="comment"> * B、10</span></span><br><span class="line"><span class="comment"> * C、undefined</span></span><br><span class="line"><span class="comment"> * D、报错</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure></li><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =&gt; 全局下的变量提升var n,var c, a=AAAFFF</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有作用域，形参赋值：无，变量提升：var n， b=BBBFFF</span></span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">10</span> <span class="comment">//  n=&gt; 11 n=&gt; 12</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 私有作用域</span></span><br><span class="line">        n++ <span class="comment">// n为上级作用域的</span></span><br><span class="line">        <span class="built_in">console</span>.log(n)</span><br><span class="line">    &#125;</span><br><span class="line">    b() <span class="comment">// 输出11</span></span><br><span class="line">    <span class="keyword">return</span> b <span class="comment">// return BBBFFF</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = a() <span class="comment">// c为BBBFFF，此时a函数中的私有作用域不销毁</span></span><br><span class="line">c() <span class="comment">//再次执行BBBFFF n=&gt;12</span></span><br><span class="line"><span class="built_in">console</span>.log(n) <span class="comment">// 输出全局n， 即 0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选C</span></span><br><span class="line"><span class="comment"> * A、1 1 1</span></span><br><span class="line"><span class="comment"> * B、11 11 0</span></span><br><span class="line"><span class="comment"> * C、11 12 0</span></span><br><span class="line"><span class="comment"> * D、11 12 12</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure></li><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局下的变量提升var a, var b, var c, 声明并定义test = AAAFFF</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>, b = <span class="number">11</span>, c = <span class="number">12</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 私有作用域a=10，var b </span></span><br><span class="line">    a = <span class="number">1</span> <span class="comment">// 私有a由10变为1</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span> <span class="comment">// 私有b=2</span></span><br><span class="line">    c = <span class="number">3</span>  <span class="comment">// 全局c由12变为3</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 全局a = 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 全局b = 11</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 全局c = 3</span></span><br></pre></td></tr></table></figure></li><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先不管条件是否成立，都要进行变量提升</span></span><br><span class="line"><span class="keyword">if</span>(!(<span class="string">'a'</span> <span class="keyword">in</span> <span class="built_in">window</span>))&#123; <span class="comment">// 变量提升后window.a = undefined =&gt; 'a' in window 为true</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span> <span class="comment">// a = 1 未执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量提升 var a, 声明及定义b=BBBFFF</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">x, y, a</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 执行b形成私有作用域x=1,y=2,a=3</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 私有a=3</span></span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">10</span> <span class="comment">// 非严格模式下，arguments和形参有映射关系 a 变为 10</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 私有a=10</span></span><br><span class="line">&#125;</span><br><span class="line">a = b(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// b函数没有返回值，此时a为undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 全局a变为undefined</span></span><br></pre></td></tr></table></figure></li><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量提升 var a, var f, fn = AAAFFF</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">9</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a = <span class="number">0</span> <span class="comment">// 执行fn形成私有作用域，全局a变为0， return BBBFFF</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b + a++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn() <span class="comment">// 不销毁</span></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">5</span>)) <span class="comment">// 5+a++ =&gt; 5+0++ =&gt; 5 // 此时全局a变为1 BBBFFF111销毁 AAAFFF不销毁</span></span><br><span class="line"><span class="built_in">console</span>.log(fn()(<span class="number">5</span>)) <span class="comment">// fn重新开辟空间并执行，a重置为0=&gt; fn()(5) =&gt; 5+0++ =&gt; 5 // 此时a为1 fn=AAAFFF临时不销毁，等fn()()即BBBFFF222执行完毕后再销毁</span></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">5</span>)) <span class="comment">// 5+a++ =&gt; 5+1++ =&gt; 6 // 此时a为2 BBBFFF222销毁 AAAFFF不销毁</span></span><br></pre></td></tr></table></figure></li><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量提升var ary = AAAFFF111, var res, fn = AAAFFF222</span></span><br><span class="line"><span class="keyword">var</span> ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">ary</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 将ary的地址赋值给形参， 私有ary和全局ary指向同一个内存空间。没有直接关系，但是存在间接关系</span></span><br><span class="line">    ary[<span class="number">0</span>] = <span class="number">0</span> <span class="comment">// 私有ary = [0, 2, 3, 4] =&gt;全局ary的值也同时被改变</span></span><br><span class="line">    ary = [<span class="number">0</span>] <span class="comment">// 私有ary重新开辟空间 ary = [0]，此时的ary与全局ary无任何关联</span></span><br><span class="line">    ary[<span class="number">0</span>] = <span class="number">100</span> <span class="comment">// 私有ary重新赋值 ary = [100]</span></span><br><span class="line">    <span class="keyword">return</span> ary <span class="comment">// 返回私有ary = [100]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> res = fn(ary)</span><br><span class="line"><span class="built_in">console</span>.log(ary) <span class="comment">// 全局ary = [0, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// ary = [100]</span></span><br></pre></td></tr></table></figure></li><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(n+(--i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn(<span class="number">2</span>) <span class="comment">// 不销毁</span></span><br><span class="line">f(<span class="number">3</span>)<span class="comment">//4  不销毁  i变为了1</span></span><br><span class="line">fn(<span class="number">4</span>)(<span class="number">5</span>)<span class="comment">//8 重新形参赋值，开辟空间</span></span><br><span class="line">fn(<span class="number">6</span>)(<span class="number">7</span>)<span class="comment">//12 重新形参赋值，开辟空间</span></span><br><span class="line">f(<span class="number">8</span>)<span class="comment">//8  不销毁  i变为了0</span></span><br><span class="line"><span class="comment">// 此题与第7题类似</span></span><br></pre></td></tr></table></figure></li><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量提升var num,var obj, var fn</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">num</span>: <span class="number">20</span> &#125; <span class="comment">// 开辟空间</span></span><br><span class="line">obj.fn = (<span class="function"><span class="keyword">function</span> (<span class="params">num</span>)</span>&#123; <span class="comment">// 添加属性fn=</span></span><br><span class="line">    <span class="keyword">this</span>.num = num*<span class="number">3</span> <span class="comment">// this: window =&gt;windwow.num = 60</span></span><br><span class="line">    num++ <span class="comment">// =&gt; num = 21</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; <span class="comment">//开辟空间BBBFFF111</span></span><br><span class="line">        <span class="keyword">this</span>.num += n</span><br><span class="line">        num++ <span class="comment">// 让上级作用域中num++ =&gt; 22</span></span><br><span class="line">        <span class="built_in">console</span>.log(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(obj.num)</span><br><span class="line"><span class="keyword">var</span> fn = obj.fn <span class="comment">// BBBFFF111 不销毁</span></span><br><span class="line">fn(<span class="number">5</span>) <span class="comment">// window.num = window.num+5 =&gt; window.num = 60+5 = 65</span></span><br><span class="line">obj.fn(<span class="number">10</span>) <span class="comment">// this: obj =&gt; num+=n =&gt; num = 30 // num++ =&gt; 23</span></span><br><span class="line"><span class="built_in">console</span>.log(num, obj.num) <span class="comment">// 65 30</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this的考查</title>
      <link href="/2020/09/04/this%E7%9A%84%E8%80%83%E6%9F%A5/"/>
      <url>/2020/09/04/this%E7%9A%84%E8%80%83%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>关于this的考查部分题目如下：</p><a id="more"></a><ol><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fullName = <span class="string">'language'</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    fullName = <span class="string">'javascript'</span>,</span><br><span class="line">    prop = &#123;</span><br><span class="line">        getFullName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.fullName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.prop.getFullName()) <span class="comment">// this为obj.prop，故输出undefined</span></span><br><span class="line"><span class="keyword">var</span> test = obj.prop.getFullName</span><br><span class="line"><span class="built_in">console</span>.log(test()) <span class="comment">// this为window，故输出'language'</span></span><br></pre></td></tr></table></figure></li><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span></span><br><span class="line"><span class="keyword">var</span> Tom = &#123;</span><br><span class="line">    name: <span class="string">'Tom'</span>,</span><br><span class="line">    show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    wait: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fun = <span class="keyword">this</span>.show</span><br><span class="line">        fun()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Tom.wait() <span class="comment">// this: Tom =&gt; fun = Tom.show =&gt;fun() =&gt; this: window =&gt; 输出window.name =&gt; 'window'</span></span><br></pre></td></tr></table></figure></li><li>输出代码结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun.prototype = &#123; <span class="comment">// 此时fun的constructor改变，指向了Object</span></span><br><span class="line">    b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="number">20</span></span><br><span class="line">        alert(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;,</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="number">30</span></span><br><span class="line">        alert(<span class="keyword">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> my_fun = <span class="keyword">new</span> fun()</span><br><span class="line">my_fun.b() <span class="comment">// 私有的方法b  this: my_fun =&gt; my_fun.a =&gt; '0'</span></span><br><span class="line">my_fun.c() <span class="comment">// 公有的方法c  this: my_fun =&gt; my_fun.c =&gt; '30'(把当前示例私有属性由0改为了30)</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经(虾皮)</title>
      <link href="/2020/09/04/%E9%9D%A2%E7%BB%8F-%E8%99%BE%E7%9A%AE/"/>
      <url>/2020/09/04/%E9%9D%A2%E7%BB%8F-%E8%99%BE%E7%9A%AE/</url>
      
        <content type="html"><![CDATA[<p>以下为虾皮一面部分面试题:</p><a id="more"></a><ol><li>输出以下结果<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="string">'Parent'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tom</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="string">'Tom'</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.__proto__.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// Parent.__proto__实际上指向Object.prototype</span></span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">4</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line">Parent.print() <span class="comment">// 4</span></span><br><span class="line">Tom.print() <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="built_in">console</span>.log(child.a) <span class="comment">// Parent</span></span><br><span class="line">child.print() <span class="comment">// 报错 child.print is not a function</span></span><br></pre></td></tr></table></figure></li><li>f能不能拿到a方法和b方法？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Function</span>.prototype.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"><span class="comment">// f最终指向为Object的prototype，所有只能拿到a方法</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经(yz)</title>
      <link href="/2020/09/01/%E9%9D%A2%E7%BB%8F-yz/"/>
      <url>/2020/09/01/%E9%9D%A2%E7%BB%8F-yz/</url>
      
        <content type="html"><![CDATA[<p>yz某公司部分面试题，学习记录如下</p><a id="more"></a><ol><li>svg是什么？<ul><li>SVG 意为可缩放矢量图形（Scalable Vector Graphics）。</li><li>SVG 使用 XML 格式定义图像。</li></ul></li><li>什么情况下用vuex？<ul><li>多个组件间需要传递参数或状态时</li><li>较大型项目使用</li></ul></li><li>vue本身的更新机制了解吗？ <ul><li>Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</li><li>简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。</li><li>同步里执行的方法，每个方法里做的事情组成一个事件循环；接下来再次调用的是另一个事件循环。</li><li>nextTick：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，会获取更新后的 DOM。 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改变数据</span></span><br><span class="line">vm.message = <span class="string">'changed'</span></span><br><span class="line"><span class="comment">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">// 并不会得到'changed'</span></span><br><span class="line"><span class="comment">//这样可以，nextTick里面的代码会在DOM更新后执行</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">//可以得到'changed'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li>computed和watch的了解？<ul><li>computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值，而 watch 则是当数据发生变化便会调用执行函数</li><li>从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据;</li></ul></li><li>observer和watcher的了解？<ul><li>Vue 响应系统，其核心有三点：observe、watcher、dep：<ul><li>observe：遍历 data 中的属性，使用 Object.defineProperty 的 get/set 方法对其进行数据劫持；</li><li>dep：每个属性拥有自己的消息订阅器 dep，用于存放所有订阅了该属性的观察者对象；</li><li>watcher：观察者（对象），通过 dep 实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动注销watch</span></span><br><span class="line"><span class="keyword">const</span> unwatch = app.$watch(<span class="string">'text'</span>, &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    deep: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>vue3.0有什么特性？<ul><li><a href="https://www.cnblogs.com/Rivend/p/12630779.html" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li><li>vue中的Object.defineProperty()有什么缺陷？<ul><li>Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</li><li>Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍。Proxy可以劫持整个对象，并返回一个新的对象。</li><li>Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li></ul></li><li>var与let、const的区别<ul><li>var声明变量存在变量提升，let和const不存在变量提升， window可以访问到var声明的值</li><li>let、const都是块级局部变量</li><li>同一作用域下let和const不能声明同名变量，而var可以</li></ul></li><li>什么是块级作用域？<ul><li>JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。块作用域由 {} 包括，if语句和for语句里面的{}也属于块作用域。</li></ul></li><li>js中的class是怎么实现的？<ul><li><a href="https://blog.csdn.net/weixin_33681778/article/details/88038531" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li><li>js基础类型和引用类型<ul><li>es5中基础类型包括：number，string，null，undefined，Boolean。es6新增了一种基础类型symbol,基础类型的存储是存放在栈中，原因是基础类型存储的空间很小，存放在栈（stack）中方便查找，且不易于改变</li><li>引用类型是指有多个值构成的对象，也就是对象类型比如：Object,Array,Function,Data等，js的引用数据类型是存储在堆中（heap），也就是说存储的变量处的值是一个指针（point），指向存储对象的内存地址。存在堆中的原因是：引用值的大小会改变，所以不能放在栈中，否则会降低变量查询的速度</li></ul></li><li>哪些方法判断值的类型？<ul><li><a href="https://www.jianshu.com/p/967d6db70437" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul><ol><li>typeof 运算符</li><li>instanceof</li><li>通过Object下的toString.call()方法来判断</li><li>根据对象的contructor判断</li></ol></li><li>instance of底层实现机制<ul><li>只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false</li></ul></li><li>水平居中的几种方式<ul><li><a href="https://blog.csdn.net/weixin_42291381/article/details/81624935" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li><li>BFC(block formatting context)<ul><li><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener">此链接内容可供参考</a></li><li>使 BFC 内部浮动元素不会到处乱跑</li><li>和浮动元素产生边界</li></ul></li><li>如何创建BFC<ol><li>float的值不是none。</li><li>position的值不是static或者relative。</li><li>display的值是inline-block、table-cell、flex、table-caption或者inline-flex</li><li>overflow的值不是visible</li></ol></li><li>触发 BFC<ul><li>只要元素满足下面任一条件即可触发 BFC 特性：<ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul></li></ul></li><li>流式布局<ul><li><a href="https://www.cnblogs.com/zylseo/p/12599443.html" target="_blank" rel="noopener">此链接内容可供参考</a></li><li><a href="https://www.jianshu.com/p/4a6e5162e4ee" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li><li>css的选择器和对应的优先级<ul><li><a href="https://blog.csdn.net/b954960630/article/details/79560590" target="_blank" rel="noopener">此链接内容可供参考</a></li><li>!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</li></ul></li><li>移动端自适应布局与字体大小自适应<ul><li><a href="https://blog.csdn.net/w390058785/article/details/80562776" target="_blank" rel="noopener">此链接内容可供参考</a></li><li>vw, vh</li><li>用js去计算并设置html标签的font-size大小</li></ul></li><li>em和rem的区别<ul><li>rem 单位翻译为像素值是由 html 元素的字体大小决定的。 此字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位</li><li>em 单位转为像素值，取决于他们使用的字体大小。 此字体大小受从父元素继承过来的字体大小，除非显式重写与一个具体单位</li></ul></li><li>数组遍历方法<ul><li><a href="https://www.cnblogs.com/QuietWinter/p/9115855.html" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li><li>post和get<ul><li>Get产生一个TCP数据包；Post产生两个TCP数据包。</li><li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；对于POST，浏览器先发送header，服务器响应100（continue），然后再发送data，服务器响应200（返回数据）；</li><li>GET幂等，POST不幂等(幂等是指同一个请求方法执行多次和仅执行一次的效果完全相同。)</li></ul></li><li>强制缓存和协商缓存<ul><li><a href="https://blog.csdn.net/zl399615007/article/details/84534884?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li><li>http头部字段有哪些？<ul><li><a href="https://www.cnblogs.com/soldierback/p/11714052.html" target="_blank" rel="noopener">此链接内容可供参考</a></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么需要node作为中间层</title>
      <link href="/2020/09/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81node%E4%BD%9C%E4%B8%BA%E4%B8%AD%E9%97%B4%E5%B1%82/"/>
      <url>/2020/09/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81node%E4%BD%9C%E4%B8%BA%E4%B8%AD%E9%97%B4%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>通常我们把Web领域分为客户端和服务端，也就是前端和后端，这里的后端就包含了网关，静态资源，接口，缓存，数据库等。而中间层呢，就是在后端这里再抽离一层出来，在业务上处理和客户端衔接更紧密的部分，比如页面渲染（SSR），数据聚合，接口转发等等。<br>以SSR来说，在服务端将页面渲染好，可以加快用户的首屏加载速度，避免请求时白屏，还有利于网站做SEO，他的好处是比较好理解的。那么对于数据的聚合，接口转发来说，这样做有什么意义呢？</p><a id="more"></a><ul><li>用Node的原因有以下：<ul><li>代理：在开发环境下，我们可以利用代理来，解决最常见的跨域问题；在线上环境下，我们可以利用代理，转发请求到多个服务端</li><li>缓存：缓存其实是更靠近前端的需求，用户的动作触发数据的更新，node中间层可以直接处理一部分缓存需求。</li><li>限流：node中间层，可以针对接口或者路由做响应的限流。</li><li>日志：相比其他服务端语言，node中间层的日志记录，能更方便快捷的定位问题（是在浏览器端还是服务端）。</li><li>监控：擅长高并发的请求处理，做监控也是合适的选项。</li><li>鉴权：有一个中间层去鉴权，也是一种单一职责的实现。</li><li>路由：前端更需要掌握页面路由的权限和逻辑。</li><li>服务端渲染：node中间层的解决方案更灵活，比如SSR、模板直出、利用一些JS库做预渲染等等。</li><li>更多的可能性</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/07/hello-world/"/>
      <url>/2020/05/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
